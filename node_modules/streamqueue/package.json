{
  "name": "streamqueue",
  "version": "0.0.4",
  "description": "Pipe queued streams progressively.",
  "homepage": "https://github.com/nfroidure/StreamQueue",
  "main": "src/index.js",
  "scripts": {
    "test": "node_modules/mocha/bin/mocha tests/*.mocha.js"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/nfroidure/StreamQueue"
  },
  "keywords": [
    "queue",
    "streaming",
    "stream",
    "async",
    "pipe"
  ],
  "devDependencies": {
    "mocha": "1.x.x",
    "event-stream": "1.x.x"
  },
  "author": {
    "name": "Nicolas Froidure",
    "url": "http://www.insertafter.com/blog.html"
  },
  "engines": {
    "node": ">= 0.10.0"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "https://github.com/nfroidure/StreamQueue/blob/master/LICENSE"
    }
  ],
  "bugs": {
    "url": "https://github.com/nfroidure/StreamQueue/issues"
  },
  "readme": "# StreamQueue [![NPM version](https://badge.fury.io/js/streamqueue.png)](https://npmjs.org/package/streamqueue) [![Build Status](https://travis-ci.org/nfroidure/StreamQueue.png?branch=master)](https://travis-ci.org/nfroidure/StreamQueue)\n\nStreamQueue pipe the queued streams one by one in order to preserve their content\n order.\n\n##Â Usage\nInstall the [npm module](https://npmjs.org/package/streamqueue):\n```sh\nnpm install streamqueue --save\n```\nThen, in your scripts:\n```js\nvar streamqueue = require('streamqueue');\n\nvar queue = streamqueue(\n  Fs.createReadStream('input.txt'),\n  Fs.createReadStream('input2.txt'),\n  Fs.createReadStream('input3.txt')\n).pipe(process.stdout);\n```\n\nObject-oriented traditionnal API offers more flexibility:\n```js\nvar StreamQueue = require('streamqueue');\n\nvar queue = new StreamQueue();\nqueue.queue(\n  Fs.createReadStream('input.txt'),\n  Fs.createReadStream('input2.txt'),\n  Fs.createReadStream('input3.txt')\n);\nqueue.done();\n\nqueue.pipe(process.stdout);\n```\nYou can also chain StreamQueue methods like that:\n```js\nvar StreamQueue = require('streamqueue');\n\nnew StreamQueue()\n  .queue(Fs.createReadStream('input.txt'))\n  .queue(Fs.createReadStream('input2.txt'))\n  .queue(Fs.createReadStream('input3.txt'))\n  .done()\n  .pipe(process.stdout);\n```\n\nYou can queue new streams at any moment until you call the done() method. So the\n created stream will not fire the end event until done() call.\n\nNote that stream queue is compatible with the Node 0.10+ streams. For older\n streams, stream queue will wrap them with\n [`Readable.wrap`](http://nodejs.org/api/stream.html#stream_readable_wrap_stream)\n before queueing.\n\n## API\n\n### StreamQueue([options], [stream1, stream2, ... streamN])\n\n#### options.objectMode\nType: `Boolean`\nDefault value: `false`\n\nUse if piped in streams are in object mode. In this case, the stream queue will\n also be in the object mode.\n\n#### options.pauseFlowingStream\nType: `Boolean`\nDefault value: `true`\n\nIf a stream is in flowing mode, then it will be paused before queueing.\n\n#### options.resumeFlowingStream\nType: `Boolean`\nDefault value: `true`\n\nIf a stream is in flowing mode, then it will be resumed before piping.\n\n#### options.*\n\nStreamQueue inherits of Stream.PassThrough, the options are passed to the\n parent constructor so you can use it's options too.\n\n#### streamN\nType: `Stream`\n\nAppend streams given in argument to the queue and ends when the queue is empty.\n\n### StreamQueue.queue(stream1, [stream2, ... streamN])\n\nAppend streams given in argument to the queue.\n\n### StreamQueue.done([stream1, stream2, ... streamN])\n\nAppend streams given in argument to the queue and ends when the queue is empty.\n\n\n## Contributing\nFeel free to pull your code if you agree with publishing it under the MIT license.\n\n",
  "readmeFilename": "README.md",
  "_id": "streamqueue@0.0.4",
  "dist": {
    "shasum": "ab3e4dfb100ea725e28f9ec08b39ee8ed930f81b"
  },
  "_from": "streamqueue@",
  "_resolved": "https://registry.npmjs.org/streamqueue/-/streamqueue-0.0.4.tgz"
}
